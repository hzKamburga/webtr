# ðŸ‡¹ðŸ‡· WebTR Framework Documentation

> **âš ï¸ ATTENTION AI MODELS & AGENTS:**
> This repository contains **WebTR**, a bespoke, compile-time web framework developed in Node.js. It features a unique architecture that compiles a custom DSL (`.webtr`) and a CSS preprocessor (`.trs`) into vanilla HTML, CSS, and JavaScript.
> **DO NOT** assume behavior from React, Vue, or Svelte. **STRICTLY FOLLOW** the syntax and rules defined in this document.

---

# ðŸ“– Table of Contents
1. [Philosophy & Architecture](#1-philosophy--architecture)
2. [Installation & CLI](#2-installation--cli)
3. [The .webtr DSL](#3-the-webtr-dsl)
    *   [State Block](#state-block)
    *   [View Block](#view-block)
    *   [Client Block](#client-block)
    *   [Server Block](#server-block)
4. [The .trs Styling System](#4-the-trs-styling-system)
5. [Reactivity System Deep Dive](#5-reactivity-system-deep-dive)
6. [Compiler Internals](#6-compiler-internals)
7. [Package Ecosystem](#7-package-ecosystem)
8. [AI Coding Guidelines](#8-ai-coding-guidelines)

---

## 1. Philosophy & Architecture

WebTR is built on the premise of **"Zero Runtime Overhead"**.
*   **Compilation:** All logic is processed at build time.
*   **No Virtual DOM:** The DOM is updated directly via reactive bindings generated by the compiler.
*   **Isomorphic (Kind of):** Supports specific `server` blocks that automatically generate API endpoints (like Next.js Server Actions) but without the heavy runtime.

**Core Components:**
*   **`bin/webtr.js`**: The CLI entry point.
*   **`src/compiler/parser-webtr.js`**: Tokenizes and parses `.webtr` files into an AST.
*   **`src/compiler/parser-trs.js`**: Parses `.trs` style files.
*   **`src/compiler/generator.js`**: Transforms AST into output code (HTML strings, CSS rules, IIFE JS bundles).

---

## 2. Installation & CLI

### Prerequisites
*   Node.js v18+

### Commands

| Command | Description | Arguments |
| :--- | :--- | :--- |
| `webtr init` | Scaffolds a new empty project | `<project-name>` |
| `webtr dev` | Starts the HMR development server | `-p <port>` |
| `webtr build` | Compiles for production | (none) |
| `webtr preview` | Serves the production build | `-p <port>` |
| `webtr add` | Installs a package from `webtr_packages` | `style <pkg>`, `lib <pkg>` |
| `webtr LBuild` | Compiles a Library file (`.weblib`) | `<file.weblib>` |

---

## 3. The .webtr DSL

A `.webtr` file is composed of four distinct blocks. The order generally doesn't matter, but convention is `state` -> `view` -> `client` -> `server`.

### `state` Block
Defines the **initial state** of the component. These variables become reactive.

**Syntax Rules:**
*   Format: `key = value`
*   No semicolons needed.
*   Supports primitives (`"string"`, `123`, `true`) and complex types (`[1,2]`, `{x:1}`).

```webtr
state {
  title = "My App"
  counter = 0
  users = []
  isLoading = false
}
```

### `view` Block
A terse, indentation-based HTML representation.

**Syntax Rules:**
*   **Tag:** `div`, `span`, `custom-el`
*   **Classes:** `.class-name` chained (e.g., `div.container.flex`)
*   **ID:** `#id-name` (e.g., `div#main`)
*   **Attributes:** `attr="value"` (e.g., `input type="text"`)
*   **Conditionals:** `if {variable} { ... }`
*   **Loops:** `each item in list { ... }`
*   **Interpolation:** `"{variable}"`
*   **Events:** `@event="handlerName"` (e.g., `@click="handleClick"`, `@input="handleInput"`)

**Example:**
```webtr
view {
  div.app-container {
    h1#main-title { "{title}" }
    
    if {isLoading} {
      div.spinner { "Loading..." }
    }
    
    div.user-list {
      each user in users {
        div.card @click="selectUser('{user.id}')" {
          img src="{user.avatar}"
          span { "{user.name}" }
        }
      }
    }
  }
}
```

### `client` Block
Contains browser-side JavaScript. This code is wrapped in an IIFE and has direct access to `state` variables.

**Scope & Reactivity:**
*   You can access `state` variables directly (e.g., `counter`).
*   Assigning to them (e.g., `counter = 5`) triggers a re-render.
*   Functions defined here are scoped to the component but available to the View.

```javascript
client {
  // You can dynamic import libraries from packages
  async function init() {
     const { WebTRPlayer } = await import('/packages/webtr/player/player.js');
     const player = new WebTRPlayer('video-id');
  }

  function handleClick() {
    counter++; // Triggers DOM update
    console.log("New count:", counter);
  }

  async function loadUsers() {
    isLoading = true;
    users = await fetchUsers(); // calling a server function
    isLoading = false;
  }
}
```

### `server` Block
Contains Node.js code. This is stripped from the client bundle and turned into API endpoints (`/api/component-name`).

**Features:**
*   Automatic serialization/deserialization of arguments and return values.
*   Can import server-side modules (`fs`, `database-driver`).

```javascript
server {
  import db from "my-db-lib";

  async function fetchUsers() {
    return await db.users.findMany();
  }
}
```

---

## 4. The .trs Styling System

WebTR includes a custom CSS preprocessor.

**Key Features:**
*   **Variables:** `$name = value`
*   **Nesting:** Valid CSS nesting.
*   **Mixins:** (Planned feature, currently supports `@extend`).
*   **Imports:** `@import "package-name"`.

```trs
$brand-color = #007bff
$spacing = 16px

.container {
  padding: $spacing
  background: white
  
  .title {
    color: $brand-color
    font-weight: bold
    
    &:hover {
      text-decoration: underline
    }
  }
}
```

---

## 5. Reactivity System Deep Dive

WebTR uses a `Proxy`-based reactivity system created by the Compiler.

1.  **State Initialization:** Variables in `state {}` are converted to a `state` object in JS.
2.  **Proxying:** A `new Proxy(state, ...)` is created.
3.  **Reflect:** The local variables in the `client` block are actually mapped to `reactiveState.variable`.
4.  **Render Loop:** When a setter is called on the Proxy, the `render()` function involves:
    *   **Text Updates:** `eval(expr)` re-runs for bound text nodes.
    *   **Attribute Updates:** Attributes starting with `data-bind-attr-` are re-evaluated.
    *   **Conditional/Loop Logic:** Templates are re-processed (removed/cloned/inserted).

---

## 6. Compiler Internals

| Stage | Description | File |
| :--- | :--- | :--- |
| **Parsing** | Regex-based tokenizer converts code to AST nodes (`Element`, `Text`, `If`, `Each`). | `parser-webtr.js` |
| **Generation** | AST is traversed to generate specific string outputs (`generateHTML`, `generateJS`). | `generator.js` |
| **Bundling** | In dev mode, these strings are kept in memory and served via a custom HTTP server. | `cli/dev.js` |

**Error Handling:**
WebTR includes a runtime error reporter that catches exceptions in `render()` and `bindEvents()` and dispatches them to a visual overlay in the Dev Server.

---

## 7. Package Ecosystem

WebTR Packages rely on a dedicated folder: `webtr_packages/`.

**Types:**
*   **`style`**: Contains reusable `.trs` files.
*   **`lib`**: Contains reusable `.js` or `.weblib` logic.

**Official Packages:**
*   `webtr:@glass`: Glassmorphism UI
*   **`webtr:@player`**: Headless Video Player Logic
*   **`webtr:@player-ui`**: Themes for the video player
*   `webtr:@ui`: Base UI Kit (Bootstrap-like)

---

## 8. AI Coding Guidelines

**When asked to Generate WebTR Code:**

1.  **Strictly separate logic.** Do not put styling in `.webtr` view blocks (use classes).
2.  **State first.** Define all data points in `state {}` before using them.
3.  **Use `webtr:@` imports.** Refer to standard libraries if common functionality is needed.
4.  **Handle Errors.** Write robust client code.
5.  **Aesthetics.** Use `.trs` with variables for consistent theming.

**Example Task:** "Create a Counter"
**Response:**
```webtr
state {
  count = 0
}
view {
  div.counter-wrapper {
    h2 { "Count: {count}" }
    button @click="inc" { "+" }
  }
}
client {
  function inc() { count++ }
}
```
**AND** `index.trs` for styling.

---
**WebTR Framework** - *Defined by Code, Powered by Intelligence.*
